Wait/notify - механизм взаимодействия потоков
Механизм может быть вызван ТОЛЬКО из синхронизированного контекста

Методы:
wait() - вынуждает вызывающий поток исполнения уступить монитор и перейти в состояние ожидания до тех пор, пока какой-нибудь другой поток не войдет в тот же монитор и не вызовет метод notify()
notify() - возобновляет исполнение потока, из которого был вызван метод wait() для того же самого монитора
notifyAll() - возобновляет исполнение всех потоков, из которых был вызван метод wait() для того же самого монитора. Одному из этих потоков предоставляется доступ

Особенности:
1.Методы реализованы в классе Object, поэтому доступны всем классам

Пример:
public class WaitNotifyClass {
    private final Object mon = new Object();
    private volatile char currentLetter = 'A';
    public static void main(String[] args) {
        WaitNotifyClass waitNotifyObj = new WaitNotifyClass();
        Thread thread1 = new Thread(() -> {
            waitNotifyObj.printA();
        });
        Thread thread2 = new Thread(() -> {
            waitNotifyObj.printB();
        });
        thread1.start();
        thread2.start();
    }
    public void printA() {
        synchronized (mon) {
            try {
                for (int i = 0; i < 10; i++) {
                    while (currentLetter != 'A') {
                        mon.wait();
                    }
                    System.out.print("A");
                    currentLetter = 'B';
                    mon.notify();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void printB() {
        synchronized (mon) {
            try {
                for (int i = 0; i < 10; i++) {
                    while (currentLetter != 'B') {
                        mon.wait();
                    }
                    System.out.print("B");
                    currentLetter = 'A';
                    mon.notify();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

В приведенном выше примере два потока синхронизируют свою работу с помощью методов wait() и notify(). Переменная currentLetter указывает на букву, которая должна быть отпечатана в текущий
момент времени. При запуске невозможно предсказать какой из потоков начнет выполнение первым. Если первый запускается поток B, то он просто переходит в режим ожидания. После чего поток А производит
печать буквы A в консоль, меняет значение переменной currentLetter, и будит поток B. Если поток A зайдет на второй шаг цикла, то увидит что сейчас не его очередь печатать и перейдет в состояние wait. Теперь поток B производит печать буквы B в консоль, меняет значение переменной currentLetter, и будит поток A. Такой “цикл действий” выполняется 10 раз