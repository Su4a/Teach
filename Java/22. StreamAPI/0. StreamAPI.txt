Stream API - эффективный инструмент для обработки коллекций в функциональном стиле
Stream API обеспечивает функциональный стиль работы с данными, предлагая более компактный, выразительный и читаемый код, а также облегчая параллельное выполнение операций

Основы Stream API:
Stream API не предлагает решения для всех возможных сценариев обработки данных. Однако, большинство задач могут быть описаны следующим общим шаблоном:
1.Источник данных
2.Выполнение преобразований
3.Сохранение результата в новую структуру данных
Если ваша задача не соответствует этому шаблону, то, возможно, использование Stream API не будет оптимальным решением

Компоненты Stream API:
Stream API состоит из набора компонентов и концепций, которые работают вместе, чтобы обеспечить потоковую обработку данных
1.Источник (Source) - откуда приходят данные. Это может быть коллекция, массив, файл, генератор или любой другой источник данных
2.Поток (Stream) - последовательность элементов, подлежащих параллельной или последовательной обработке
3.Операции - преобразовывают и/или обрабатывают данные
4.Пайплайн (Pipeline) - последовательность операций в потоке, применяемых к данным
5.Терминал (Terminal) - место выхода данных из потока. Терминальная операция означает окончание обработки потока и возвращает результат

Источники даных для потоков:
Stream API способен работать с разнообразными источниками данных
Это могут быть коллекции, списки, наборы, массивы, строки, файлы или даже генераторы чисел.
Все эти источники могут быть легко преобразованы в потоки для последующей обработки

Важно отметить, что при выполнении Stream исходные данные не изменяются 
В результате своей работы Stream создает новую структуру данных

Операции над потоком:
Все операции с потоками можно условно разделить на промежуточные и терминальные:
Промежуточные операции: 
- Промежуточные операции в потоках Java описываются декларативно с использованием лямбда-выражений. Эти операции представляют собой своего рода "рецепт" обработки данных
- Однако стоит учесть, что они не выполняются немедленно после объявления. В действительности, все промежуточные операции выполняются только при вызове терминальной операции, которая запускает общую цепочку обработки
- Важной характеристикой промежуточных операций является то, что каждая из них возвращает новый объект Stream. Это позволяет нам связывать несколько операций в одну "цепочку" (Pipeline)
Терминальные операции:
- Терминальные операции выводят конечный результат обработки потока. Они могут включать в себя перебор элементов, подсчет элементов, сбор элементов в коллекцию, поиск элементов и т.д.
- Именно терминальная операция запускает поток. После ее вызова происходит анализ операций в пайплайне, и определяется эффективная стратегия его выполнения
- Важно помнить, что потоки можно использовать только один раз. После вызова терминальной операции тот же поток использовать повторно нельзя. Попытка реализовать "наследование" пайплайнов не увенчается успехом. При попытке выполнить "второй наследник", вы столкнетесь с ошибкой

Как работает Stream:
- Каждый элемент потока обрабатывается индивидуально
- Сначала первый элемент проходит через пайплайн, затем второй, затем третий
Это важно для эффективности и надлежащего функционирования потоков в Java!

Что же такое Stream?
Центральной концепцией Stream API является потоковые операции, представляющие собой ряд последовательных действий, выполняемых над данными
Основные свойства потоков:
1.Декларативность: Потоки в Java описывают, что должно быть сделано, а не конкретный способ его выполнения.
2.Ленивость: Это означает, что потоки не выполняют никакой работы, пока не будет вызвана терминальная операция.
3.Одноразовость: После того как терминальная операция была вызвана на потоке, этот поток больше не может быть использован. Если необходимо применить другую операцию к данным, потребуется новый поток.
4.Параллельность: Несмотря на то, что потоки в Java по умолчанию выполняются последовательно, их можно легко распараллелить.

Продвинутые советы и использование:
1.Возвращать Stream<T> вместо коллекций
Это позволит защитить вашу коллекцию внутри сущности, не позволяя ее модифицировать извне
Так же потребитель вашего API сможет сам выбрать, какая коллекция ему нужна














































