В контексте конструкторов, применять this нужно в двух случаях:
1. Когда у переменной экземпляра класса и переменной метода/конструктора
одинаковые имена;
2. Когда нужно вызвать конструктор одного типа (например, конструктор по
умолчанию или параметризированный) из другого. Это еще называется явным
вызовом конструктора. Внимательно посмотрев на параметризированный
конструктор (листинг 3), видим, что переменные в параметрах называются не
также, как поля класса.


Ключевое слово this в Java используется только в составе экземпляра
класса. Но неявно ключевое слово this передается во все методы, кроме
статических (поэтому this часто называют неявным параметром) и может
быть использовано для обращения к объекту, вызвавшему метод.


Опасно:
Нельзя просто сделать названия параметров идентичными названиям
полей, в этом случае возникает проблема. Для примера возьмём имя кота,
поле String name. Один String name принадлежит классу Cat, а другой String
name находится в локальной видимости конструктора. JVM, как и любой
другой электрический прибор всегда идёт по пути наименьшего
сопротивления, когда есть неопределённость. То есть, когда написана
строка name = name; Java берётсамую близкую name из конструктора и для
левой и для правой части оператора присваивания, что не имеет никакого
смысла.

Использование ключевого слова this для конструктора:
public class Cat {
String name;
String color;
int age;

public Cat(String name, String color) {
this.name = name;
this.color = color;
}

public Cat(String name, String color, int age) {
this(name, color);
this.age = age;
}
// ...
}

Использование ключевого слова this для копирования объекта из конструктора:
public Cat (Cat cat) {
this(cat.name, cat.color, cat.age);
}

Благодаря имеющемуся конструктору со всеми нужными параметрами, с помощью
ключевого слова this явно вызывается конструктор заполняющий все поля
создаваемого кота, значениями из переданного объекта, фактически, его
копирующий. То, что мы имеем здесь, – это неглубокая копия. Если класс имеет
изменяемые поля, например, массивы, то мы можем вместо простой сделать
глубокую копию внутри его конструктора копирования. При глубокой копии вновь
созданный объект не должен зависеть от исходного, а значит просто скопировать
ссылку на массив будет недостаточно


