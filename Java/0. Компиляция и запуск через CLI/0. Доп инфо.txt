https://habr.com/ru/articles/125210/

Для корректной работы самого инструментария и сторонних приложений,
использующих инструментарий, проследите, пожалуйста, что установлены
следующие переменные среды ОС:
— в системную PATH добавить путь до исполняемых файлов JDK,
например, для UNIX-подобных систем:
PATH=$PATH:/usr/lib/jvm/jdk1.8.0_221/bin
— JAVA_HOME путь до корня JDK, например, для UNIX-подобных систем:
JAVA_HOME=/usr/lib/jvm/jdk1.8.0_221/
— JRE_HOME путь до файлов JRE из состава установленной JDK,
например, для UNIX-подобных систем:
JRE_HOME=/usr/lib/jvm/jdk1.8.0_221/jre/
— J2SDKDIR устаревшая переменная для JDK, используется некоторыми
старыми приложениями, например, для UNIX-подобных систем:
J2SDKDIR=/usr/lib/jvm/jdk1.8.0_221/
— J2REDIR устаревшая переменная для JRE, используется некоторыми
старыми приложениями, например, для UNIX-подобных
систем:J2REDIR=/usr/lib/jvm/jdk1.8.0_221/jre/


— JDK = JRE + инструменты разработчика;
— JRE = JVM + библиотеки классов;
— JVM = Native API + механизм исполнения + управление памятью


Как именно всё работает? Если коротко, то слой за слоем накладывая абстракции.
Программы на любом языке программирования исполняются на компьютере, то
есть, так или иначе, задействуют процессор, оперативную память и прочие
аппаратурные компоненты. Эти аппаратурные компоненты предоставляют для
доступа к себе низкоуровневые интерфейсы, которые задействует операционная
система, предоставляя в свою очередь интерфейс чуть проще программам,
взаимодействующим с ней. Этот интерфейс взаимодействия с ОС мы для простоты
будем называть Native API. С ОС взаимодействует JVM (Wikipedia: Список
виртуальных машин Java), то есть, используя Native API, нам становится всё равно,
какая именно ОС установлена на компьютере, главное уметь выполняться на JVM.
Это открывает простор для создания целой группы языков, они носят общее
бытовое название JVM-языки, к ним относят Scala, Groovy, Kotlin и другие. Внутри
JVM осуществляется управление памятью, существует механизм исполнения
программ, специальный JIT1
1
-компилятор, генерирующий
платформенно-зависимый код. JVM для своей работы запрашивает у ОС некоторый
сегмент оперативной памяти, в котором хранит данные программы. Это хранение
происходит «слоями»:
1. Eden Space (heap) – в этой области выделяется память под все создаваемые
из программы объекты. Большая часть объектов живёт недолго (итераторы,
временные объекты, используемые внутри методов и т.п.), и удаляются при
выполнении сборок мусора это области памяти, не перемещаются в другие
области памяти. Когда данная область заполняется (т.е. количество
выделенной памяти в этой области превышает некоторый заданный
процент), сборщик мусора выполняет быструю (minor collection) сборку. По
сравнению с полной сборкой, она занимает мало времени, и затрагивает
только эту область памяти, а именно, очищает от устаревших объектов Eden
Space и перемещает выжившие объекты в следующую область.
2. Survivor Space (heap) – сюда перемещаются объекты из предыдущей области
после того, как они пережили хотя бы одну сборку мусора. Время от времени
долгоживущие объекты из этой области перемещаются в Tenured Space.
3. Tenured (Old) Generation (heap) — Здесь скапливаются долгоживущие объекты
(крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и
прочие). Когда заполняется эта область, выполняется полная сборка мусора
(full, major collection), которая обрабатывает все созданные JVM объекты.
4. Permanent Generation (non-heap) – Здесь хранится метаинформация,
используемая JVM (используемые классы, методы и т.п.).
5. Code Cache (non-heap) — эта область используется JVM, когда включена
JITкомпиляция, в ней кешируется скомпилированный
платформенно-зависимый код.

JVM самостоятельно осуществляет сборку так называемого мусора, что
значительно облегчает работу программиста по отслеживанию утечек памяти, но
важно помнить, что в Java утечки памяти всё равно существуют, особенно при
программировании многопоточных приложений.

На пользовательском уровне важно не только исполнять базовые инструкции программы, но чтобы
эти базовые инструкции умели как-то взаимодействовать со внешним миром, в том числе другими
программами, поэтому JVM интегрирована в JRE - Java Runtime Environment. JRE - это набор из
классов и интерфейсов, реализующих
— возможности сетевого взаимодействия;
— рисование графики и графический пользовательский интерфейс;
— мультимедиа;
— математический аппарат; — наследование и полиморфизм;
— рефлексию;
— ... многое другое.