Куча содержит все объекты, созданные в приложении, независимо от того, какой
поток создал объект. Неважно, был ли объект создан и присвоен локальной
переменной или создан как переменная-член другого объекта, он хранится в куче.

Локальная переменная может быть примитивной, но также может быть ссылкой на
объект. В этом случае ссылка (локальная переменная) хранится на стеке, но сам
объект хранится в куче

Объект использует методы, эти методы содержат
локальные переменные. Эти локальные переменные (то есть в момент выполнения
метода) также хранятся на стеке, несмотря на то, что объект, который использует
метод, хранится в куче. Переменныечлены класса хранятся в куче вместе с самим
классом. Это верно как в случае, когда переменная-член имеет примитивный тип,
так и в том случае, если она является ссылкой на объект. Статические переменные
класса также хранятся в куче вместе с определением класса

Куча разбита на несколько более мелких частей, называемых поколениями:
— Young Generation — область где размещаются недавно созданные объекты. Когда
она заполняется, происходит быстрая сборка мусора;
— Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты
из Young Generation достигают определенного порога «возраста», они
перемещаются в Old Generation;
— Permanent Generation — эта область содержит метаинформацию о классах и
методах приложения, но начиная с Java 8 данная область памяти была упразднена.
В Java 8 Permanent Generation заменён на Metaspace - его динамически изменяемый
по размеру аналог. Именно здесь находятся статические поля.
Особенности кучи:
— В общем случае, размеры кучи на порядок больше размеров стека
— Когда эта область памяти полностью заполняется, Java бросает
java.lang.OutOfMemoryError;
— Доступ к ней медленнее, чем к стеку;
— Эта память, в отличие от стека, автоматически не освобождается. Для сбора
неиспользуемых объектов используется сборщик мусора;
— В отличие от стека, который создаётся для каждого потока свой, куча не является
потокобезопасной, поскольку для всех одна, и ее необходимо контролировать,
правильно синхронизируя код.


Также, хотелось бы отметить, что мы можем использовать -Xms и -Xmx
опции JVM, чтобы определить начальный и максимальный размер памяти в
куче. Для стека определить размер памяти можно с помощью опции -Xss