HashMap<K, V> представляет собой хеш-таблицу для хранения пар ключ-значение и обеспечивает постоянное время выполнения методов get() и put() даже при большом количестве элементов в коллекции. Типы ключа и значения могут отличаться

Имеет 2 основных параметра:
capacity - емкость, или количество элементов(bucket) во внутренней таблице HashMap, по-умолчанию начальная емкость HashMap равна 16, и всегда равна степени 2, при попытке указать в конструкторе начальную емкость равную 28, она автоматически будет увеличена до 32
loadFactor (по-умолчанию равен 0.75, должен находиться в пределах от 0.0 до 1.0) - коэффициент, который показывает что при добавлении в HashMap количества элементов большего чем capacity * loadFactor, емкость коллекции будет увеличена вдвое и произойдет рехеширование записей

HashMap<тип_ключа, тип_данных> hm = new HashMap<>()

Конструктор:
HashMap() - Создает пустой HashMap с начальной емкостью 16
HashMap(int initialCapacity) - Создает HashMap, с указанной начальной емкостью
HashMap(int initialCapacity, float loadFactor) - Создает HashMap, с указанной начальной емкостью и коэффициент заполнения
HashMap(Map<? extends K, ? extends V> m) - Создает HashMap, инициализируемый элементами из Map m

Методы коллекции:
.put(K, V) - Положить значение по ключу, заменяет значение у одинаковых ключей
.get(K) - Получить значение по ключу
.getKey() - Получить ключ
.getValue() - Получить значение

Особенности:
1. Каждая ячейка внутренней таблицы HashMap хранит в себе список пар Map.Entry<K, V> (в некоторых случаях может быть построено дерево)
2. Не гарантирует порядок расположения своих элементов, соответственно порядок их перебора может не соответствовать порядку их добавления
3. Для того, чтобы ваши собственные типы данных (классы) могли использоваться в качестве ключей HashMap, необходимо корректно реализовать методы hashCode() и equals();

Плюсы:
-HashMap предоставляет возможность быстрого поиска значения по ключу

Как происходит добавление новой пары:
● Происходит вычисление K.hashCode() — тут сразу стоит вспомнить о важности переопределения методов hashCode() и equals() в классах которые вы проектируете;
● Происходит вычисление корзины куда стоит положить данную пару - самый простой вариант который для этого может применяться (зависит от реализации и версии JVM) это деление по модулю, где модуль это текущее
количество корзин (по умолчанию 16)
● Далее мы обращаемся к связанному списку который храниться в корзине и сравниваем значение hashCode;
● Если hashCode не совпали мы добавляем новую пару в конец;
● Если hashCode совпали, то мы сравниваем K по equals;
● Если объекты K равны то просто отбрасываем новое значение;
● Если они отличаются то добавляем в конец списка. Мы помним, что hashCode может совпадать у разных объектов — коллизия

Если длина связанного списка достигает значение 8, то список превращается в бинарное дерево (для более эффективного поиска)
Перебалансировка HashMap происходит когда “Коэффициент загрузки” (Количество хранимых элементов / количество корзин) превышает допустимый коэффициент загрузки. По умолчанию коэффициент загрузки меньше 0.75 считается хорошим результатом — это значит, что при количестве корзин 16 перебалансировка произойдет если элементов станет 13

Примечания:
Всегда использовать неизменяемые типы объектов для K (Причина в том, что вы можете положить в корзину объект, который потом может измениться в процессе работы приложения, а значит измениться equals и hashCode и при попытке добавить или проверить наличие такого экземпляра, мы не сможем правильно определить корзину и добавим пару еще раз (или не найдем))