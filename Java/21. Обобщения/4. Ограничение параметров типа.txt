Bounded type parameters позволяют ограничить типы данных, которые могут быть использованы в качестве параметров
Использование bounded type parameters в Java является хорошей практикой, которая позволяет более точно определить используемые типы данных и обеспечивает более безопасный читаемый код
В коробке описывается операция сложения. Если сложение чисел и конкатенация строк – это понятные операции, то сложение котиков или
потоков ввода-вывода не определены. Применение bounded type parameters позволяет более точно задавать ограничения на используемые типы данных, что
помогает писать более безопасный и читаемый код

1. Ограничение сверху (extends)
Чтобы объявить "ограничение сверху" параметр типа необходимо после имени параметра указать ключевое слово extends, а затем указать
верхнюю границу (upper bound), которой в данном примере является класс Number
В этом случае можно польжить только те объекты, которые наследуются от Number

public class Box<V extends Number> {
  private V value;
  public V getValue() return value;
}

2. Множественное ограничение сверху
Можно задать несколько границ, при этом важно помнить, что также, как и в объявлении классов, возможен только один класс наследик и он указывается первым
Все остальные границы могут быть только интерфейсами и указываются через знак амерсанда "&"

public class CBox<T extends Bird & Animal & Man> {}

В языке Java, несмотря на строгость типизации, возможно присвоить идентификатору одного типа объект другого типа, если эти типы совместимы
Напрмиер, можно присвоить объект типа Integer переменной типа Object, т.к. Object является одним из супертипов Integer

3. Ограничение снизу (super)
Такое ограничение необходимо, когда требуется объединить несколько похожих, но все же разных типов данных
Для примера возьмем 2 класса: животное и его наследник кот, на их основе создаются обобщенные списки и вызывается обобщенный метод копирования списков

Пример:
class Animal {
  String name;
  Animal() {this.name = "Animal";}
  @Override public String toString {return name;}
}

class Cat extends Animal {
  Cat() {this.name = "Cat";} 
}

public static void copyTo(ArrayList stc, AttayList dst) {
  for (Object o : stc) dst.add(o);
}

copyTo(animals, cats);
System.out.print(cats);

При попытке вызвать у животного метод кота выбрасывается исключение о невозможности приведения типов
Для того, чтобы избежать подобных проблем, необходимо описать метод таким образом, чтобы он работать только с каким то одним типом и списки в цикле тоже будут перебираться элементом типа Т
Если более не уточнять, получится что в список котов возможно класть только котов, а в список животных класть только животных
Но кот это наследник животного, его присутствие в списке животных уместно, получается, что источником может быть список из заданного типа или его наследников, а приемником тип или его родители

При таком описании метода неверные варианты будут отсекаться на этапе компиляции:
public static <T> void copyTo(ArrayList<? extend T> src, ArrayList<? super T> dst) {
  for (T o : src) dst.add(o);
}































