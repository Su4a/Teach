Подстановочный символ (wildcard) означает неизвестный тип (любой)
Подстановочный символ может использоваться в разных ситуациях: 
- параметр типа
- параметр поля 
- параметр локальной переменной и 
- в качестве возвращаемого типа

Передаваемые типы для уточнения можно ограничить сверху и снизу:
- Box<? extends Number> - ограничение сверху
- Box<? super Integer> - ограничение снизу
В обобщенных конструкцияъ возможно указать либо только верхнюю границу для подстановочного символа, либо только нижнюю

Ограниченный сверху или подстановочный символ применяется чтобы ослабить ограничения переменной

1.Ограничение сверху
public static class TBox<T> {
  public static final TBox EMPTY_BOX = new TBox<>();
  private T value;

  public T getValue() {return value;}
  public void setValue(T value) {this.value = value;}
  static <T> TBox<T> emptyBox() {return (TBox<T>) EMPTY_BOX;}
  @Override public String toString() {return value.toString();}
}
static void printInfo(TBox<? extends Animal> animalInBox) {
  System.out.println("Information about animal: " + animalInBox);
}

Создав соответствующие объекты, положив их в коробки и запустив код возможно наблюдать, что коробка вмещает как животных, так и наследников животного, чего не произошло бы при использовании в параметре типа животного без подстановочного символа

Если использовать просто подстановочный символ, то получится подстановочный символ без ограничений (любой/неизвестный тип)

Такой синтаксис существует для того, чтобы продолжать использовать обобщенный тип без уточнения типа, как следствие, без использования обобщенной функциональности. Неограниченный подстановочный символ полезен, если нужен метод, который может быть реализован с помощью функциональности класса Object. Когда код использует методы обобщенного класса, которые не зависят от параметра типа

В программа, использующих Reflection API конструкция Class исползьзуется чаще других конструкций, потому что большинство методов объекта Класс не зависят от расположенного внутри типа
Например, метод printInfo() не использует никаких методов животного, цель метода вывод в консоль информацию об объекте в коробке любого типа, поэтому в параметре метода можно заменить коробку с наследниками животного на коробку с чем угодно, ведь в методе будет использоваться только метод коробки toString

2.Ограничение снизу
Ограниченный снизу подстановочный символ ограничивает тип так, чтобы он был либо указанным типом, либо одним из его предков

-------------------------------------------------------------

Подстановочный символ никогда не используется в качестве аргумента для вызова обобщенного метода, создания экземпляра обобщенного класса или супертипа
Обобщенные классы или интерфейсы связаны не только из за связи между их типами. С обычными, необобщенными классами, наследование работает по правилу прдчиненных типов: класс Cat является подклассом класса Animal и арсширяет его. Данное правило не работает для обобщенных типов, даже несмотря на то что Cat является подтипом Animal, Box<Cat> не является подтипом Box<Animal>. Общим предком для Box<Cat> и Box<Animal> является Box<?>

В некоторых случаях компилятор может вывести тип подстановочного символа. Коробка может быть определена как Box, но при вычислении выражения компилятор выведет конкретный тип из кода, такой сценарий называется захватом подстановочного символа. В большинстве случаев нет нужды беспокоиться о захвате подстановочного символа, кроме случаев, когда в сообщении об ошибке появляется фраза capture of

В примере компилятор обрабатывает параметр коробки как тип Object. Когда вызывается метод внутри testError(), компилятор не может подтвердить тип объекта, который будет присутствовать внутри коробки и генерирует ошибку. Обобщения были добавлены именно для этого, чтобы усилить безопасность типов на этапе компиляции

Когда есть уверенность в том, что операция безопасна, ошибку возможно исправить, написав приватный вспомогательный метод, захватывающий подстановочный символ

private static <T> void sestErrorHelper(TBox<T> box) {
  box.setValue(box.getValue());
}
static void testError(TBox<?> box) {
  testErrorHelper(box);
}

КРАТКОЕ РУКОВОДСТВО ПО ИСПОЛЬЗОВАНИЮ ПОДСТАНОВОЧНЫХ СИМВОЛОВ:
Входная переменная предоставляет данные для кода
Для метода copy(src, dst) параметр src предоставляет данные для копирования, поэтому он считается входной переменной
Выходная переменная содержит данные для использования в другом месте
В примере copy(src, dst) параметр dst принимает данные и будет считаться выходной переменной

- Входная переменная определяется ограничением сверху
- Выходная переменная определяется ограничением снизу
- Если ко входной переменной можно обращаться только как к Object - необраниченный подстановочный символ
- Если переменная должна использоваться как входная и как выходная одновременно, не использовать подстановочный символ
- Не использовать подстановочные символы в возвращаемых типах





















