Потокоориентированный ввод-вывод подразумевает чтение или запись из потока и в поток одного или нескольких байт в единицу времени поочередно
Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад
Если есть необходимость произвести подобные манипуляции, придётся сначала кэшировать данные в буфере 

Подход, на котором основан Java NIO немного отличается:
Данные считываются в буфер для последующей обработки
Становится возможно двигаться по буферу вперед и назад 
Это дает больше гибкости при обработке данных
В то же время, появляется необходимость проверять содержит ли буфер необходимый для корректной обработки объем данных
Также необходимо следить, чтобы при чтении данных в буфер не были уничтожены ещё не обработанные данные, находящиеся в буфере 

JAVA IO/NIO
Основное отличие между двумя подходами к организации ввода/вывода в том, что Java IO является потокоориентированным, а Java NIO – буфер-ориентированным
Потокоориентированный ввод-вывод подразумевает чтение или запись из потока и в поток одного или нескольких байт в единицу времени поочередно
Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад
Если есть необходимость произвести подобные манипуляции, придётся сначала кэшировать данные в буфере.

Подход, на котором основан Java NIO немного отличается:
Данные считываются в буфер для последующей обработки
Становится возможно двигаться по буферу вперед и назад 
Это дает больше гибкости при обработке данных 
В то же время, появляется необходимость проверять содержит ли буфер необходимый для корректной обработки объем данных 
Также необходимо следить, чтобы при чтении данных в буфер не были уничтожены ещё не обработанные данные, находящиеся в буфере

Потоки ввода/вывода (streams) в Java IO являются блокирующими 
Это значит, что когда в потоке выполнения вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны 
Поток выполнения (thread) в данный момент не может делать ничего другого
Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет

Каналы – это логические порталы, через которые осуществляется ввод/-вывод данных, а буферы являются источниками или приёмниками этих переданных данных 
При организации вывода, данные, которые вы хотите отправить, помещаются в буфер, а он передается в канал 
При вводе, данные из канала помещаются в предоставленный вами буфер

Также, в Java NIO появилась возможность создать поток, который будет знать, какой канал готов для записи и чтения данных и может обрабатывать этот конкретный канал
Данные считываются в буфер для последующей обработки

В Java для описания работы по вводу/выводу используется специальное понятие потока данных (stream)
Поток данных это абстракция, физически никакие потоки в компьютере никуда не текут

У каждого байтового потока есть свой литеральный аналог аналог:
Байтовый поток - Символьный поток
InputStream - Reader
OutputStream - Writer
ByteArrayInputStream - CharArrayReader
ByteArrayOutputStream - CharArrayWriter
нет аналога - InputStreamReader
нет аналога - OutputSTreamWriter
FileInputStream - FileReader
FileOutputStream - FileWriter
BufferInputStream - BufferReader
BufferOutputStream - BufferWriter
PrintStream - PrintWriter
DataInputStream - нет аналога
DataOutputStream - нет аналога
Классы мосты: InputStreamReader и OutputStreamWriter

Листинг 15: Использование буфера и канала
try (RandomAccessFile catFile = new RandomAccessFile("cat.txt",
"rw")) {
FileChannel inChannel = catFile.getChannel();
ByteBuffer buf = ByteBuffer.allocate(100);
int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {
System.out.println("Read " + bytesRead + " bytes");
// Set read mode
buf.flip();
while (buf.hasRemaining()) {
System.out.print((char) buf.get());
}
buf.clear();
bytesRead = inChannel.read(buf);
}
} catch (IOException e) { e.printStackTrace(); }
Подготовив всё необходимое, приложение прочитало данные в буфер, сохранив
число прочитанных байт, а затем прочитанные байты посимвольно были выведены
в консоль. Для чтения данных из файла используется файловый канал. Объект
файлового канала может быть создан только вызовом метода getChannel() для
файлового объекта, поскольку нельзя напрямую создать объект файлового канала.
При этом, FileChannel нельзя переключить в неблокирующий режим.









