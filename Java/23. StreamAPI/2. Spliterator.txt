Spliterator:
Предполагаю, что вам уже известно, что в основе всех коллекций лежит интерфейс Iterator, который позволяет перебрать коллекцию поэлементно. Можно сказать, что в основе стримов лежит Iterator на стеройдах, так называемый Spliterator
Spliterator используется в основе стримов в Java и играет важную роль при параллельной обработке данных, так как именно он отвечает за разделение данных на части для независимой обработки каждым потоком

Методы Spliterator:
1.long estimateSize() возвращает количество элементов
2.tryAdvance(Consumer) принимает функциональный интерфейс Consumer, который определяет действия, которые должны быть выполнены над текущим элементом
3.int characteristics() возвращает набор характеристик текущего сплитератора
4.Spliterator<T> trySplit() пытается разделить текущий сплитератор на два. Если операция успешна, то возвращает новый сплитератор, и уменьшает размер исходного сплитератора. Если разделение не возможно, то возвращает null

Характеристики Spliterator:
Spliterator обладает специальными характеристиками, которые сообщают об особенностях источника данных, из которого он был создан
Эти характеристики помогают в оптимизации работы потока при выполнении терминальных операций (например, нет смысла выполнять сортировку уже отсортированной коллекции)
1.ORDERED: указывает, что элементы имеют определенный порядок
2.DISTINCT: указывает, что каждый элемент уникален. Определяется по equals()
3.SORTED: указывает, что элементы отсортированы
4.SIZED: указывает, что размер источника известен заранее
5.NONNULL: указывает, что ни один элемент не может быть null
6.IMMUTABLE: указывает, что элементы не могут быть модифицированы
7.CONCURRENT: указывает, что исходные данные могут быть модифицированы без воздействия на Spliterator
8.SUBSIZED: указывает, что размер разделенных Spliterator-ов также будет известен

В зависимости от типа коллекции, из которой получен Spliterator, будут установлены разные характеристики. Например, для коллекции Collection будет установлен флаг SIZED, для Set добавится DISTINCT, а для SortedSet еще и SORTED
Каждая операция может менять флаги характеристик. Это важно, поскольку каждый этап обработки данных будет знать об этих изменениях, что позволяет выполнить оптимальные действия. Например, операция map() сбросит флаги SORTED и DISTINCT, так как данные могут измениться, но всегда сохранит флаг SIZED, так как размер потока не изменяется при выполнении map()






















