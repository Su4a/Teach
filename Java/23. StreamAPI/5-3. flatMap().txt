Метод flatMap() используется для создания одного потока из множества потоков
Он принимает функцию в качестве аргумента, которая применяется к каждому элементу исходного потока
Эта функция принимает элемент исходного потока и возвращает новый поток

Stateless операция
Влияние на характеристики:
ORDERED: обычно сохраняется.
DISTINCT, SORTED: обычно теряются.
SIZED, SUBSIZED: теряются.
NONNULL: может быть потеряно.
IMMUTABLE, CONCURRENT: сохраняются.

Пример:
List<List<Integer>> listOfLists = Arrays.asList(
        Arrays.asList(1, 2, 3),
        Arrays.asList(4, 5, 6),
        Arrays.asList(7, 8, 9)
);
Stream<Integer> flattenedStream = listOfLists.stream()
        .flatMap(Collection::stream);
flattenedStream.forEach(System.out::println); // prints 1, 2, 3, 4, 5, 6, 7, 8, 9

В данном примере мы начинаем со списка списков целых чисел и создаем поток с помощью метода stream()
Затем мы используем метод flatMap() для создания нового потока, включающего все целые числа из вложенных списков, путем применения метода stream() к каждому из вложенных списков
Наконец, мы используем метод forEach() для вывода каждого элемента нового потока

Особенности:
Разница между map() и flatMap():
Функция map() преобразует элемент исходного потока из одного типа в другой
В отличие от этого, функция flatMap() позволяет получить новый поток из элементов коллекций, которые были внутри элементов первого потока.

Дополнения flatMap:
flatMap, flatMapToInt, flatMapToDouble, flatMapToLong
Похоже на map, но может создавать из одного элемента несколько
collection.stream().flatMap((p) ­> Arrays.asList(p.split(",")).stream()).toArray(String[]::new)




