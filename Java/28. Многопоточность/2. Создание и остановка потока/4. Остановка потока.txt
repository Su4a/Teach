1. stop()
Java Thread содержит метод stop(), который принудительно останавливает поток
Метод stop() не дает гарантий относительно состояния, в котором поток остановили. таким образом, все объекты Java, к которым у потока был доступ во время его выполнения, останутся в неизвестном состоянии (изменения состояния объектов не будут зафиксированы и видны другим потокам), что может привести к ошибкам — например при выполнении потока создается ресурс (например подключение к базе данных), который не будет закрыт и как следствие мы получим утечку памяти

2. interrupt()
Если метод stop(), принудительно останавливал поток, то interrupt() только предлагает потоку остановить свое выполнение путем установки флага interrupted в true внутри потока — решение об остановке принимает сам код потока. Данный флаг отображает статус прерывания (значение по умолчанию false)
Если поток прерывается другим потоком то происходит следующее:
- Если поток ожидает выполнения прерываемого метода блокирования (Thread.sleep(), Thread.join() или Object.wait()), то процесс ожидание прерывается и выбрасывает InterruptedException — после этого флаг interrupted устанавливается в значение false
- Если поток не ожидает выполнения прерываемого метода блокирования, флаг interrupted устанавливается в значение true — теперь код потока должен обработать переменную в реализации метода run

3. Thread.sleep()
Метод Thread.sleep() может принимать в качестве параметра количество миллисекунд — время на которое поток попытается заснуть, возобновлением выполнения — обратите внимание, что абсолютная точность не гарантирована
В операционной системе, с установленной JVM, имеется свой планировщик потоков, называемый Thread Scheduler. Данный планировщик принимает решение, какой поток и когда необходимо запускать


