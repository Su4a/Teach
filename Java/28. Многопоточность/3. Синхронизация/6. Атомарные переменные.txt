В Java нам доступны классы атомарных переменных: AtomicInteger AtomicLong, AtomicBoolean, AtomicReference
Эти алгоритмы называются compare and swap (CAS) и базируются на том, что современные процессоры поддерживают некоторые операции на уровне машинных инструкций

Алгоритм compare and swap работает следующим образом: есть ячейка памяти, текущее значение в ней и то значение, которое хотим записать в эту ячейку. Сначала ячейка памяти читается и сохраняется текущее значение, затем прочитанное значение сравнивается с тем, которое уже есть в ячейке памяти, и если значение прочитанное ранее совпадает с текущим, происходит запись нового значения. Следует упомянуть, что значение переменной после чтения может быть изменено другим потоком, потому что CAS не является блокирующей операцией

Чтобы избежать состояния гонки, мы можем использовать synchronized-методы, synchronized-блоки (volatile нам в данном случае не подойдет). Без использования механизма синхронизации, результат может быть непредсказуемым, а значение не будет иметь никакого смысла для нашей программы. Но как было уже сказано выше, процесс синхронизации дорогостоящая операция, требующая существенных ресурсов CPU. Также этот способ блокирующий — одновременно выполняется только один поток, что сильно влияет на производительность системы в целом. Для решения этой проблемы мы можем использовать неблокирующие алгоритмы.. Эти алгоритмы называются compare and swap (CAS) и базируются на том, что современные процессоры поддерживают некоторые операции на уровне машинных инструкций






