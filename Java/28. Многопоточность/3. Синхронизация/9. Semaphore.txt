Semaphore один из примитивов синхронизации, позволяющий определить N потоков, которым позволено исполнять критическую секцию кода
Когда создается Semaphore, в конструктор передается количество разрешенных потоков (пропуск)
Представьте, что вам нужно реализовать приложение для контроля количества свободных мест на парковке - если места на парковке закончились, то остальные машины должны ждать пока место не освободится
Когда один из потоков попадает в Semaphore - количество допустимых пропусков уменьшается (при освобождении наоборот увеличивается). Вы можете в методе захвата семафора (acquire()) указать, какое количество пропусков возьмет поток, а в методе освобождения (release()) сколько будет возвращено (это количество не может быть больше, чем захваченное количество пропусков).
Если передать в конструктор вторым параметром true, потоки, которые ожидают получение пропуска (хотят войти в критическую секцию), выстраиваются в очередь (вместо blocking set используется очередь по типу FIFO)

private static Integer count = Integer.valueOf(0);
  public static void main(String[] args) {
    Semaphore sem = new Semaphore (2); // N разрешений
    new Thread(new CountThread(sem)).start(); 
    new Thread(new Count Thread(sem)).start();
    new Thread(new Count Thread(sem)).start();
  }

  static class CountThread implements Runnable {
    Semaphore sem;
    CountThread(Semaphore sem) {
      this.sem sem;
    }
    public void run() {
      try {
        System.out.println(Thread.currentThread().getName() + ожидает разрешение");
        sem.acquire(); //получения разрешения у семафора 
        for (int i = 1; i < 5; i++) {
          System.out.println(Thread.currentThread().getName() + ": " + count);
          count++;
          Thread.sleep(100);
        }
      } catch (InterruptedException e) {
          System.out.println(e.getMessage());
      }
      System.out.println(Thread.currentThread().getName() +
      sem.release(); // Освобождение монитора
    }
  }


















