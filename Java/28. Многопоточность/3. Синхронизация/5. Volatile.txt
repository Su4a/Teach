Ключевое слово volatile указывает, что взаимодействие потоков с этой переменной должно происходить минуя кэш процессора, т. е. напрямую (т.е. запрещено копировать переменную из Heap)

Когда потоки используют переменные (не volatile), они могут копировать значение этих переменных в кэш CPU для улучшения производительности. Если вы используете процессор с несколько ядрами, при этом каждый из потоков выполняется на отдельном ядре, то одна и та же переменная может находиться в разном состоянии на каждом ядре CPU. В результате мы получим несколько копий одной и той же переменной: копии в кэше каждого ядра процессора и копия переменной в Heap
При использовании не volatile переменных нельзя знать наверняка, когда JVM читает значение переменной из главной памяти и когда записывается значение в главную память

Ключевое слово volatile гарантирует нам следующее:
● Если поток X пишет в volatile переменную, а затем второй поток Y читает значение, тогда все переменные, видимые потоку X перед записью в переменную volatile, также будут видны потоку Y после того как он прочитал переменную volatile.
● Если поток X читает переменную volatile, то все переменные, видимые потоку X при чтении переменной volatile, также будут перечитаны из основной памяти.

Примечание: 
Помните, что объявление переменной как volatile достаточно, только когда один поток изменяет переменную, а другой поток читает ее значение - Если два потока одновременно меняют состояние переменной, то volatile уже недостаточно — все равно может быть race condition

