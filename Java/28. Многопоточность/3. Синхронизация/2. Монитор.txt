У любого наследника класса Object есть свой собственный монитор
Монитор характеризуется следубщей информацией:
● состоянии (locked) — признак, что монитор захвачен потоком;
● владелец (owner) — каким потоком захвачен монитор в текущий момент;
● перечень потоков, которые не смогли захватить монитор (blocked set), так как монитор захвачен другим потоком;
● перечень потоков у которых был вызван метод wait (wait set)

Для синхронизации потоков используется ключевое слово synchronized
Синхронизируется именно объект, только у него есть монитор

Существует возможность в качестве монитора использовать POJO (Plain Old Java Object, самые обычные Java объекты)

Давайте посмотрим, что происходит, когда поток пытается захватить монитор объекта:
● Поток попадает в синхронизированный блок кода (synchronized блок);
● В синхронизированном объекте проверяются переменные locked и owner монитора.
● Если эти поля false и null, соответственно, они заполняются. Если переменная owner не равна потоку, который хочет захватить монитор, то поток блокируется и попадает в blocked set монитора
● Поток начал выполнять код (соответствует открывающей фигурной скобке
synchronized блока)
● Поток завершил выполнение кода (соответствует закрывающейся фигурной скобке блока синхронизации)
● Переменные locked и owner монитора очищаются
Можно создать отдельные POJO мониторы и использовать их при синхронизации:

synchronized (монитор) {блок кода}

Пример:
public class SynchDoubleCounter {
	private long first;
	private long second;
	private Object monFirst = new Object();
	private Object monSecond = new Object();
	public long getFirst() {
		return first;
	}
	public long getSecond() {
		return second;
	}
	public void incrementFirst() {
		synchronized (monFirst) {
		first++;
		}
	}
	public void incrementSecond() {
		synchronized (monSecond) {
		second++;
		}
	}
	public void decrementFirst() {
		synchronized (monFirst) {
			first--;
		}
	}
	public void decrementSecond() {
		synchronized (monSecond) {
			second--;
		}
	}
}

В таком случае, поток, вызывающий метод изменения переменной first, будет захватывать монитор monFirst, а параллельный поток, вызывающий метод изменения переменной second, будет соответственно захватывать monSecond


