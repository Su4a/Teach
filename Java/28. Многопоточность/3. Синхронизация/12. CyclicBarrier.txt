CyclicBarrier работает аналогично CountDownLatch, но есть несколько отличий:
- вместо методов countDown() и await() используется один метод await(), после вызова которого поток блокируется (если число не равно нулю);
- класс CyclicBarrier можно использовать повторно. Как только значение счетчика становится равным нулю, оно восстанавливается, и объект класса можно использовать заново;
- как только значение счетчика стало равным нулю, у вас есть возможность выполнить дополнительный метод имплементирующий интерфейс runnable, который может быть передан в конструктор CyclicBarrier.

В качестве примера можно привести приложение для паромной переправы — пока паром не будет заполнен машины на 100% он не должен начинать движение.

public static void main(String args[]) throws InterruptedException {
  CyclicBarrier ciclicBarrier = new CyclicBarrier(3);
  new Car(3000, latch, "CAR-1").start(); 
  new Car(2000, latch, "CAR-2").start(); 
  new Car(1000, latch, "CAR-3").start(); 
  // Ждем три потока 
  latch.await();

  System.out.println(Thread.currentThread().getName()+" has finished");
}

  static class Car extends Thread {
    private int delay;
    private CyclicBarrier ciclicBarrier;

    public Car(int delay, CyclicBarrier ciclicBarrier, String name) {
      super(name);
      this.delay delay;
      this.ciclicBarrier = ciclicBarrier;
    }

    @Override
    public void run() {
      try {
        Thread.sleep(delay); 
        ciclicBarrier.await();
        System.out.println(Thread.currentThread().getName() + " finished");
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }