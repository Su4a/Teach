CopyOnWriteArrayList следует применять, когда в вашем приложении есть множество потоков которые читают элементы из коллекции, и только несколько (относительно небольшое) потоков, которые редко пишут данные в коллекцию — т.е. изменение элементов коллекции происходит не часто (например некий справочник со статусами объектов). В качестве примера использования можно привести задачу с обработкой данных, полученных от некоторого источника (например сигнал GPS датчиков) — каждый поток должен обработать все данные — множество принимающих станций только читают сигнал

При попытке записи структура Copy on write фактически создает новую копию данных. Это позволяет нескольким потокам одновременно читать данные, и одному потоку записывать элементы в коллекцию в каждый конкретный момент времени
- Copy on write содержит volatile массив элементов и при каждом изменении коллекции: добавлении, удалении или замене элементов, создается новая локальная копия такого массива для изменений. После модификации измененная копия становится текущей.
- volatile используется используется для того, чтобы все потоки сразу увидели изменения в массиве (значением переменной не копируется в кэш CPU). Такой алгоритм гарантирует, что потоки которые будут читать не изменяющиеся во времени данные, а при параллельном внесении изменений не будет выброшено исключение — ConcurrentModificationException
- Не вызывайте remove() при использовании Iterator для чтения коллекции — будет сгенерировано UnsupportedOperationException, потому что текущая копия коллекции не подлежит изменению
- Для операций записи внутри класса CopyOnWriteArrayList создается блокировка, чтобы в конкретный момент времени только один поток мог изменять copy on write структуру данных

