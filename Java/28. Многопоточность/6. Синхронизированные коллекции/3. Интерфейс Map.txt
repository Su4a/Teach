Есть несколько реализаций интерфейса Map для использования в многопоточных коллекциях: HashTable, ConcurrentHashMap и ConcurrentSkipListMap
Такие коллекции, реализующие интерфейс Map позволяют нам решать прикладные задачи, связанные с отображением список используемых сразу в нескольких потоков. Представьте, что мы реализуем многопользовательское приложение - клиенту проходят процедуру идентификации, аутентификации и авторизуются - наша задача обеспечить хранение Map отображения идентификатора клиента на его сессию (любая сессия может обрабатываться любым потоком)

В первую очередь стоит упомянуть конечно же HashTable - это классическая реализация интерфейса Map, все методы которой синхронизированы - по этой причине она является deprecated и не рекомендована к применению

Сегодня мы рассмотрим наиболее популярную реализацию - ConcurrentHashMap. ConcurrentHashMap это массив сегментов, каждый из которых представляет собой HashMap с массивом корзин. Мы помним, что каждая корзина или бакет HashMap это связанный список или бинарное дерево.
И так давайте посмотрим, что происходит при работе с ConcurrentHashMap:
- При добавлении значения (пары ключ и значение) блокируется только один из сегментов, а после добавления пары все происходит, как в обычной Map.
- При чтении, сегменты не блокируются - несколько потоков могут читать данные одновременно.
- Параллельное изменение возможно, только при обращении к двум разным сегментам.
- При внесении изменений в один из сегментов, другой поток может читать из него параллельно. При одновременном чтении и модификации данных в результате чтения вернется последнее измененное значение.
- Рехеширование в ConcurrentHashMap происходит по отдельности в каждом сегменте, поэтому оно может выполняться одновременно с записью в другой сегмент.