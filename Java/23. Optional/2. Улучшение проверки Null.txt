С Optional мы можем понять наличие объекта с помощью isPresent() и получить его с помощью get()

Начнем с упаковки результата coffee.getSugar() с Optional и использованием метода isPresent()
Это поможет нам определить, возвращает ли getSugar() значение null

Coffee coffee = new Coffee();
Optional<String> sugar = Optional.ofNullable(coffee.getSugar());
int quantity = 0;
if (sugar.isPresent()) {
  Sugar sugar = sugar.get();
  int quantity = sugar.getQuantity();
}
Глядя на этот пример, упаковка результата coffee.getSugar() в Optional, похоже, не прибавляет никакой ценности, а скорее добавляет хлопот

Мы можем улучшить результат, используя то, что я считаю своими любимыми функциями из класса Optional:
map(Function<? super T,? extends U> mapper) — преобразует значение, содержащееся в Optional, с предоставленной функцией. Если параметр Optional пуст, то map() вернет Optional.empty()
orElse(T other) — это “специальная” версия метода get(). Она может получить значение, содержащееся в Optional. Однако в случае пустого Optional это вернет значение, переданное в метод orElse()

Метод вернет значение, содержащееся в экземпляре Optional. 
Но если параметр Optional пуст, то есть он не содержит значения, тогда orElse() вернет значение, переданное в сигнатуру его метода, которое известно как значение по умолчанию

Coffee coffee = new Coffee();
Integer quantity = Optional.ofNullable(coffee.getSugar())
    .map(it -> it.getQuantity())
    .orElse(0);

Теперь, если в случае пустого значения мы не хотим возвращать значение по умолчанию, то нам нужно создать какое-то исключение
orElseThrow(Supplier<? extends X> exceptionSupplier) возвращает значение, содержащееся в параметрах Optional, или выдает исключение в случае пустого Optional

Coffee coffee = new Coffee();
Integer quantity = Optional.ofNullable(coffee.getSugar())
  .map(it -> it.getQuantity())
  .orElseThrow(IllegalArgumentException::new);
